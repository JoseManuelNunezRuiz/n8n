"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatHubService = void 0;
const api_types_1 = require("@n8n/api-types");
const backend_common_1 = require("@n8n/backend-common");
const db_1 = require("@n8n/db");
const di_1 = require("@n8n/di");
const n8n_workflow_1 = require("n8n-workflow");
const uuid_1 = require("uuid");
const credentials_helper_1 = require("../../credentials-helper");
const not_found_error_1 = require("../../errors/response-errors/not-found.error");
const workflow_execute_additional_data_1 = require("../../workflow-execute-additional-data");
const workflow_execution_service_1 = require("../../workflows/workflow-execution.service");
const credentials_service_1 = require("../../credentials/credentials.service");
const active_executions_1 = require("../../active-executions");
let ChatHubService = class ChatHubService {
    constructor(logger, credentialsService, credentialsHelper, executionRepository, workflowExecutionService, workflowRepository, projectRepository, sharedWorkflowRepository, activeExecutions) {
        this.logger = logger;
        this.credentialsService = credentialsService;
        this.credentialsHelper = credentialsHelper;
        this.executionRepository = executionRepository;
        this.workflowExecutionService = workflowExecutionService;
        this.workflowRepository = workflowRepository;
        this.projectRepository = projectRepository;
        this.sharedWorkflowRepository = sharedWorkflowRepository;
        this.activeExecutions = activeExecutions;
        this.sesssions = new Map();
    }
    async getModels(user, credentialIds) {
        const additionalData = await (0, workflow_execute_additional_data_1.getBase)({ userId: user.id });
        const responses = await Promise.all(api_types_1.chatHubProviderSchema.options.map(async (provider) => {
            const credentialId = credentialIds[provider];
            if (!credentialId) {
                return [provider, { models: [] }];
            }
            await this.credentialsService.getOne(user, credentialId, false);
            const credentials = await this.credentialsHelper.getDecrypted(additionalData, {
                id: credentialId,
                name: api_types_1.PROVIDER_CREDENTIAL_TYPE_MAP[provider],
            }, api_types_1.PROVIDER_CREDENTIAL_TYPE_MAP[provider], 'internal', undefined, true);
            const apiKey = this.extractApiKey(provider, credentials);
            if (!apiKey) {
                return [provider, { models: [] }];
            }
            try {
                return [provider, await this.fetchModelsForProvider(provider, apiKey)];
            }
            catch {
                return [
                    provider,
                    { models: [], error: 'Could not retrieve models. Verify credentials.' },
                ];
            }
        }));
        return responses.reduce((acc, [provider, res]) => {
            acc[provider] = res;
            return acc;
        }, {
            openai: { models: [] },
            anthropic: { models: [] },
            google: { models: [] },
        });
    }
    async fetchModelsForProvider(provider, apiKey) {
        switch (provider) {
            case 'openai':
                return await this.fetchOpenAiModels(apiKey);
            case 'anthropic':
                return await this.fetchAnthropicModels(apiKey);
            case 'google':
                return await this.fetchGoogleModels(apiKey);
        }
    }
    async fetchOpenAiModels(apiKey) {
        const response = await fetch('https://api.openai.com/v1/models', {
            method: 'GET',
            headers: {
                Authorization: `Bearer ${apiKey}`,
            },
        });
        if (!response.ok) {
            throw new Error(`Failed to fetch OpenAI models: ${response.statusText}`);
        }
        const data = await response.json();
        return {
            models: data.data
                .filter((model) => model.id.includes('gpt') &&
                !model.id.includes('instruct') &&
                !model.id.includes('audio'))
                .map((model) => ({ name: model.id })),
        };
    }
    async fetchAnthropicModels(apiKey) {
        const response = await fetch('https://api.anthropic.com/v1/models', {
            method: 'GET',
            headers: {
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01',
            },
        });
        if (!response.ok) {
            throw new Error(`Failed to fetch Anthropic models: ${response.statusText}`);
        }
        const data = (await response.json());
        return {
            models: (data.data || [])
                .sort((a, b) => {
                const dateA = new Date(a.created_at);
                const dateB = new Date(b.created_at);
                return dateB.getTime() - dateA.getTime();
            })
                .map((model) => ({ name: model.id })),
        };
    }
    async fetchGoogleModels(apiKey) {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1/models?key=${apiKey}`, {
            method: 'GET',
        });
        if (!response.ok) {
            throw new Error(`Failed to fetch Google models: ${response.statusText}`);
        }
        const data = await response.json();
        return {
            models: data.models
                ?.filter((model) => model.name.includes('gemini') &&
                model.supportedGenerationMethods?.includes('generateContent'))
                .map((model) => {
                const modelId = model.name.split('/').pop();
                return { name: modelId };
            }),
        };
    }
    extractApiKey(provider, credentials) {
        if (typeof credentials !== 'object' || credentials === null) {
            return undefined;
        }
        const creds = credentials;
        switch (provider) {
            case 'openai':
            case 'anthropic':
            case 'google':
                return typeof creds.apiKey === 'string' ? creds.apiKey : undefined;
        }
    }
    async createChatWorkflow(user, sessionId, nodes, connections) {
        const { manager } = this.projectRepository;
        const existing = await this.workflowRepository.findOneBy({ id: sessionId });
        if (existing) {
            return existing;
        }
        return await manager.transaction(async (trx) => {
            const project = await this.projectRepository.getPersonalProjectForUser(user.id, trx);
            if (!project) {
                throw new not_found_error_1.NotFoundError('Could not find a personal project for this user');
            }
            const newWorkflow = new db_1.WorkflowEntity();
            newWorkflow.versionId = (0, uuid_1.v4)();
            newWorkflow.id = sessionId;
            newWorkflow.name = `Chat ${sessionId}`;
            newWorkflow.active = false;
            newWorkflow.nodes = nodes;
            newWorkflow.connections = connections;
            const workflow = await trx.save(newWorkflow);
            await trx.save(this.sharedWorkflowRepository.create({
                role: 'workflow:owner',
                projectId: project.id,
                workflow,
            }));
            return workflow;
        });
    }
    getMessage(execution) {
        const lastNodeExecuted = execution.data.resultData.lastNodeExecuted;
        if (typeof lastNodeExecuted !== 'string')
            return undefined;
        const runIndex = execution.data.resultData.runData[lastNodeExecuted].length - 1;
        const mainOutputs = execution.data.resultData.runData[lastNodeExecuted][runIndex]?.data?.main;
        if (mainOutputs && Array.isArray(mainOutputs)) {
            for (const branch of mainOutputs) {
                if (branch && Array.isArray(branch) && branch.length > 0 && branch[0].json?.output) {
                    return branch[0].json.output;
                }
            }
        }
        return undefined;
    }
    async askN8n(res, user, payload) {
        let session = this.sesssions.get(payload.sessionId);
        if (!session) {
            session = [];
            this.sesssions.set(payload.sessionId, session);
        }
        const chatHistory = session.map((msg) => ({
            type: msg.type,
            message: msg.message,
        }));
        session.push({
            id: payload.messageId,
            message: payload.message,
            type: 'user',
            createdAt: new Date(),
        });
        const nodes = [
            {
                parameters: {
                    public: true,
                    mode: 'webhook',
                    options: { responseMode: 'streaming' },
                },
                type: n8n_workflow_1.CHAT_TRIGGER_NODE_TYPE,
                typeVersion: 1.3,
                position: [0, 0],
                id: (0, uuid_1.v4)(),
                name: 'When chat message received',
                webhookId: (0, uuid_1.v4)(),
            },
            {
                parameters: {
                    promptType: 'define',
                    text: "={{ $('When chat message received').item.json.chatInput }}",
                    options: {
                        enableStreaming: true,
                    },
                },
                type: n8n_workflow_1.AGENT_LANGCHAIN_NODE_TYPE,
                typeVersion: 3,
                position: [600, 0],
                id: (0, uuid_1.v4)(),
                name: 'AI Agent',
            },
            this.createModelNode(payload),
            {
                parameters: {
                    sessionIdType: 'customKey',
                    sessionKey: "={{ $('When chat message received').item.json.sessionId }}",
                },
                type: '@n8n/n8n-nodes-langchain.memoryBufferWindow',
                typeVersion: 1.3,
                position: [500, 200],
                id: (0, uuid_1.v4)(),
                name: 'Memory',
            },
            {
                parameters: {
                    mode: 'insert',
                    messages: {
                        messageValues: chatHistory,
                    },
                },
                type: '@n8n/n8n-nodes-langchain.memoryManager',
                typeVersion: 1.1,
                position: [200, 0],
                id: (0, uuid_1.v4)(),
                name: 'Restore Chat Memory',
            },
        ];
        const connections = {
            'When chat message received': {
                main: [[{ node: 'Restore Chat Memory', type: 'main', index: 0 }]],
            },
            'Restore Chat Memory': {
                main: [[{ node: 'AI Agent', type: 'main', index: 0 }]],
            },
            'Chat Model': {
                ai_languageModel: [[{ node: 'AI Agent', type: 'ai_languageModel', index: 0 }]],
            },
            Memory: {
                ai_memory: [
                    [
                        { node: 'AI Agent', type: 'ai_memory', index: 0 },
                        { node: 'Restore Chat Memory', type: 'ai_memory', index: 0 },
                    ],
                ],
            },
        };
        const workflow = await this.createChatWorkflow(user, payload.sessionId, nodes, connections);
        const workflowData = {
            ...workflow,
            nodes,
            connections,
            versionId: (0, uuid_1.v4)(),
        };
        const startNodes = [{ name: 'Restore Chat Memory', sourceData: null }];
        const triggerToStartFrom = {
            name: 'When chat message received',
            data: {
                startTime: Date.now(),
                executionTime: 0,
                executionIndex: 0,
                executionStatus: 'success',
                data: {
                    main: [
                        [
                            {
                                json: {
                                    sessionId: `${payload.sessionId}-${payload.messageId}`,
                                    action: 'sendMessage',
                                    chatInput: payload.message,
                                },
                            },
                        ],
                    ],
                },
                source: [null],
            },
        };
        this.logger.debug(`Starting execution of workflow "${workflow.name}" with ID ${workflow.id}`);
        const { executionId } = await this.workflowExecutionService.executeManually({
            workflowData,
            startNodes,
            triggerToStartFrom,
        }, user, undefined, true, res);
        if (!executionId) {
            throw new n8n_workflow_1.OperationalError('There was a problem starting the chat execution.');
        }
        const result = await this.activeExecutions.getPostExecutePromise(executionId);
        if (!result) {
            throw new n8n_workflow_1.OperationalError('There was a problem executing the chat workflow.');
        }
        const execution = await this.executionRepository.findWithUnflattenedData(executionId, [
            workflow.id,
        ]);
        if (!execution) {
            throw new not_found_error_1.NotFoundError(`Could not find execution with ID ${executionId}`);
        }
        const message = this.getMessage(execution);
        if (message) {
            this.logger.debug(`Assistant: ${message} (${payload.replyId})`);
            session.push({
                id: payload.replyId,
                message,
                type: 'ai',
                createdAt: new Date(),
            });
        }
    }
    createModelNode(payload) {
        const common = {
            position: [600, 200],
            id: (0, uuid_1.v4)(),
            name: 'Chat Model',
            credentials: payload.credentials,
        };
        switch (payload.model.provider) {
            case 'openai':
                return {
                    ...common,
                    parameters: {
                        model: { __rl: true, mode: 'list', value: payload.model.model },
                        options: {},
                    },
                    type: '@n8n/n8n-nodes-langchain.lmChatOpenAi',
                    typeVersion: 1.2,
                };
            case 'anthropic':
                return {
                    ...common,
                    parameters: {
                        model: {
                            __rl: true,
                            mode: 'list',
                            value: payload.model.model,
                            cachedResultName: payload.model.model,
                        },
                        options: {},
                    },
                    type: '@n8n/n8n-nodes-langchain.lmChatAnthropic',
                    typeVersion: 1.3,
                };
            case 'google':
                return {
                    ...common,
                    parameters: {
                        model: { __rl: true, mode: 'list', value: payload.model.model },
                        options: {},
                    },
                    type: '@n8n/n8n-nodes-langchain.lmChatGoogleGemini',
                    typeVersion: 1.2,
                };
        }
    }
    async getConversations() {
        const now = new Date();
        const today = new Date(now);
        const yesterday = new Date(now);
        yesterday.setDate(yesterday.getDate() - 1);
        const threeDaysAgo = new Date(now);
        threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);
        const twoWeeksAgo = new Date(now);
        twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);
        const twoMonthsAgo = new Date(now);
        twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
        return [
            {
                id: '7f3e2a91-8c4d-4b5a-9e1f-2d6c8a4b5e7f',
                title: 'Getting Started with n8n',
                createdAt: today.toISOString(),
                updatedAt: today.toISOString(),
            },
            {
                id: '3a8f5c2d-1e9b-4d7a-8c3e-6f2a9b4d8e1c',
                title: 'Workflow Automation Ideas',
                createdAt: yesterday.toISOString(),
                updatedAt: yesterday.toISOString(),
            },
            {
                id: '9b2e4f6a-7d1c-4a8b-9e3f-5c7d2a8b4e6f',
                title: 'API Integration Help',
                createdAt: threeDaysAgo.toISOString(),
                updatedAt: threeDaysAgo.toISOString(),
            },
            {
                id: '5c8a1d3e-4b9f-4e2a-8d6c-7f3a9b2e4c8d',
                title: 'Database Schema Design',
                createdAt: twoWeeksAgo.toISOString(),
                updatedAt: twoWeeksAgo.toISOString(),
            },
            {
                id: '2f6d9a4c-8e1b-4d7a-9c3e-6a8f2b5d4e9c',
                title: 'Docker Deployment Questions',
                createdAt: twoMonthsAgo.toISOString(),
                updatedAt: twoMonthsAgo.toISOString(),
            },
        ];
    }
    async getConversationMessages(conversationId) {
        this.logger.debug(`Fetching messages for conversation ${conversationId}`);
        const mockConversations = {
            '7f3e2a91-8c4d-4b5a-9e1f-2d6c8a4b5e7f': [
                {
                    id: '650e8400-e29b-41d4-a716-446655440001',
                    conversationId,
                    role: 'user',
                    content: 'How do I create my first workflow in n8n?',
                    createdAt: new Date('2025-01-08T10:00:00Z').toISOString(),
                },
                {
                    id: '650e8400-e29b-41d4-a716-446655440002',
                    conversationId,
                    role: 'assistant',
                    content: "To create your first workflow in n8n:\n\n1. Click the '+' button in the top left\n2. Select 'Create New Workflow'\n3. Add nodes by clicking the '+' on the canvas\n4. Configure each node\n5. Connect nodes by dragging from one to another\n6. Test and activate your workflow\n\nWould you like help with a specific type of workflow?",
                    createdAt: new Date('2025-01-08T10:00:30Z').toISOString(),
                },
                {
                    id: '650e8400-e29b-41d4-a716-446655440003',
                    conversationId,
                    role: 'user',
                    content: 'Yes, I want to automate sending emails when a new row is added to a Google Sheet.',
                    createdAt: new Date('2025-01-08T10:05:00Z').toISOString(),
                },
                {
                    id: '650e8400-e29b-41d4-a716-446655440004',
                    conversationId,
                    role: 'assistant',
                    content: "Perfect! Here's how to set that up:\n\n1. Add a **Google Sheets Trigger** node\n   - Select 'On Row Added'\n   - Connect your Google account\n   - Choose your spreadsheet\n\n2. Add a **Gmail** node\n   - Connect your Gmail account\n   - Set the recipient email\n   - Use expressions to include data from the sheet\n\n3. Activate the workflow\n\nWould you like more details on any of these steps?",
                    createdAt: new Date('2025-01-08T10:05:45Z').toISOString(),
                },
            ],
            '3a8f5c2d-1e9b-4d7a-8c3e-6f2a9b4d8e1c': [
                {
                    id: '650e8400-e29b-41d4-a716-446655440011',
                    conversationId,
                    role: 'user',
                    content: 'What are some creative workflow automation ideas?',
                    createdAt: new Date('2025-01-07T14:30:00Z').toISOString(),
                },
                {
                    id: '650e8400-e29b-41d4-a716-446655440012',
                    conversationId,
                    role: 'assistant',
                    content: 'Here are some creative workflow automation ideas:\n\n**Social Media Automation:**\n- Auto-post blog content to multiple platforms\n- Monitor mentions and send notifications\n- Generate reports on engagement metrics\n\n**Business Operations:**\n- Sync data between CRM and accounting software\n- Auto-generate invoices from project completion\n- Send weekly team reports\n\n**Personal Productivity:**\n- Save email attachments to cloud storage\n- Create calendar events from emails\n- Track expenses from receipts\n\nWhich area interests you most?',
                    createdAt: new Date('2025-01-07T14:32:00Z').toISOString(),
                },
                {
                    id: '650e8400-e29b-41d4-a716-446655440013',
                    conversationId,
                    role: 'user',
                    content: 'The social media automation sounds great! How complex is it to set up?',
                    createdAt: new Date('2025-01-07T14:45:00Z').toISOString(),
                },
                {
                    id: '650e8400-e29b-41d4-a716-446655440014',
                    conversationId,
                    role: 'assistant',
                    content: "It's actually quite straightforward! For auto-posting to multiple platforms:\n\n**Difficulty: Beginner-friendly**\n\n1. Use an **RSS** trigger to monitor your blog\n2. Add **Twitter**, **LinkedIn**, and **Facebook** nodes\n3. Format your message with expressions\n4. Add conditions to customize per platform\n\nMost of the work is just connecting your accounts. The actual workflow can be set up in under 30 minutes!\n\nWant me to walk you through the specific nodes you'll need?",
                    createdAt: new Date('2025-01-07T14:47:00Z').toISOString(),
                },
            ],
            '9b2e4f6a-7d1c-4a8b-9e3f-5c7d2a8b4e6f': [
                {
                    id: '650e8400-e29b-41d4-a716-446655440021',
                    conversationId,
                    role: 'user',
                    content: "I'm having trouble integrating with the Stripe API. Any tips?",
                    createdAt: new Date('2025-01-06T09:00:00Z').toISOString(),
                },
                {
                    id: '650e8400-e29b-41d4-a716-446655440022',
                    conversationId,
                    role: 'assistant',
                    content: "I'd be happy to help with Stripe integration! What specific issue are you encountering?\n\n**Common Stripe integration patterns in n8n:**\n\n1. **Webhook-based** (Recommended)\n   - Stripe sends events to n8n\n   - Great for payment notifications\n   - Real-time updates\n\n2. **Polling-based**\n   - Check for new data periodically\n   - Good for reports and syncing\n\n3. **Manual trigger**\n   - Run on-demand operations\n   - Create customers, charges, etc.\n\nWhat's your use case?",
                    createdAt: new Date('2025-01-06T09:02:00Z').toISOString(),
                },
                {
                    id: '650e8400-e29b-41d4-a716-446655440023',
                    conversationId,
                    role: 'user',
                    content: 'I want to receive notifications when a payment succeeds and create an invoice in my accounting software.',
                    createdAt: new Date('2025-01-06T09:15:00Z').toISOString(),
                },
                {
                    id: '650e8400-e29b-41d4-a716-446655440024',
                    conversationId,
                    role: 'assistant',
                    content: "Perfect use case for webhooks! Here's the setup:\n\n**Step 1: n8n Webhook**\n- Add a Webhook node\n- Set method to POST\n- Copy the webhook URL\n\n**Step 2: Stripe Dashboard**\n- Go to Developers → Webhooks\n- Add endpoint with your n8n URL\n- Select `payment_intent.succeeded` event\n\n**Step 3: Process Payment Data**\n- Add a **Function** node to extract payment details\n- Parse customer, amount, currency\n\n**Step 4: Create Invoice**\n- Add your accounting software node (QuickBooks, Xero, etc.)\n- Map payment data to invoice fields\n\n**Step 5: Send Notification**\n- Add Email/Slack node for confirmation\n\nWant the specific code for the Function node?",
                    createdAt: new Date('2025-01-06T09:18:00Z').toISOString(),
                },
            ],
        };
        const messages = mockConversations[conversationId];
        if (messages) {
            return messages;
        }
        throw new not_found_error_1.NotFoundError(`Conversation not found. ID: ${conversationId}`);
    }
};
exports.ChatHubService = ChatHubService;
exports.ChatHubService = ChatHubService = __decorate([
    (0, di_1.Service)(),
    __metadata("design:paramtypes", [backend_common_1.Logger,
        credentials_service_1.CredentialsService,
        credentials_helper_1.CredentialsHelper,
        db_1.ExecutionRepository,
        workflow_execution_service_1.WorkflowExecutionService,
        db_1.WorkflowRepository,
        db_1.ProjectRepository,
        db_1.SharedWorkflowRepository,
        active_executions_1.ActiveExecutions])
], ChatHubService);
//# sourceMappingURL=chat-hub.service.js.map