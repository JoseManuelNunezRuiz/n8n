"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDateRangesCommonTableExpressionQuery = void 0;
const db_1 = require("@n8n/db");
const luxon_1 = require("luxon");
const getDatetimeSql = ({ dbType, daysFromToday, useStartOfDay = false, }) => {
    if (daysFromToday === 0 && !useStartOfDay) {
        return dbType === 'sqlite' ? "datetime('now')" : 'NOW()';
    }
    if (dbType === 'sqlite') {
        if (daysFromToday === 0 && useStartOfDay) {
            return "datetime('now', 'start of day')";
        }
        if (useStartOfDay) {
            return `datetime('now', '-${daysFromToday} days', 'start of day')`;
        }
        return `datetime('now', '-${daysFromToday} days')`;
    }
    if (dbType === 'postgresdb') {
        if (daysFromToday === 0 && useStartOfDay) {
            return "DATE_TRUNC('day', NOW())";
        }
        if (useStartOfDay) {
            return `DATE_TRUNC('day', NOW() - INTERVAL '${daysFromToday} days')`;
        }
        return `NOW() - INTERVAL '${daysFromToday} days'`;
    }
    if (daysFromToday === 0 && useStartOfDay) {
        return 'DATE(NOW())';
    }
    if (useStartOfDay) {
        return `DATE(DATE_SUB(NOW(), INTERVAL ${daysFromToday} DAY))`;
    }
    return `DATE_SUB(NOW(), INTERVAL ${daysFromToday} DAY)`;
};
const getDateRangesCommonTableExpressionQuery = ({ dbType, startDate, endDate, }) => {
    const today = luxon_1.DateTime.now().startOf('day');
    const startDateStartOfDay = luxon_1.DateTime.fromJSDate(startDate).startOf('day');
    const endDateStartOfDay = luxon_1.DateTime.fromJSDate(endDate).startOf('day');
    const daysFromEndDateToToday = Math.floor(today.diff(endDateStartOfDay, 'days').days);
    const daysDiff = Math.floor(endDateStartOfDay.diff(startDateStartOfDay, 'days').days);
    const isEndDateToday = daysFromEndDateToToday === 0;
    let prevStartDateSql;
    let startDateSql;
    let endDateSql;
    if (daysDiff === 0 && isEndDateToday) {
        prevStartDateSql = getDatetimeSql({ dbType, daysFromToday: 2, useStartOfDay: false });
        startDateSql = getDatetimeSql({ dbType, daysFromToday: 1, useStartOfDay: false });
        endDateSql = getDatetimeSql({ dbType, daysFromToday: 0, useStartOfDay: false });
    }
    else {
        const dateRangeInDays = Math.max(1, daysDiff);
        const daysFromStartDateToToday = Math.floor(today.diff(startDateStartOfDay, 'days').days);
        const prevStartDaysFromToday = daysFromStartDateToToday + dateRangeInDays;
        prevStartDateSql = getDatetimeSql({
            dbType,
            daysFromToday: prevStartDaysFromToday,
            useStartOfDay: true,
        });
        startDateSql = getDatetimeSql({
            dbType,
            daysFromToday: daysFromStartDateToToday,
            useStartOfDay: true,
        });
        endDateSql = isEndDateToday
            ? getDatetimeSql({ dbType, daysFromToday: 0, useStartOfDay: false })
            : getDatetimeSql({ dbType, daysFromToday: daysFromEndDateToToday - 1, useStartOfDay: true });
    }
    return (0, db_1.sql) `SELECT
			${prevStartDateSql} AS prev_start_date,
			${startDateSql} AS start_date,
			${endDateSql} AS end_date
	`;
};
exports.getDateRangesCommonTableExpressionQuery = getDateRangesCommonTableExpressionQuery;
//# sourceMappingURL=insights-by-period-query.helper.js.map