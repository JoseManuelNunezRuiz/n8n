"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var VectorStoreRedis_node_exports = {};
__export(VectorStoreRedis_node_exports, {
  VectorStoreRedis: () => VectorStoreRedis,
  getParameter: () => getParameter,
  getParameterAsNumber: () => getParameterAsNumber,
  getRedisClient: () => getRedisClient,
  listIndexes: () => listIndexes,
  redisConfig: () => redisConfig
});
module.exports = __toCommonJS(VectorStoreRedis_node_exports);
var import_redis = require("@langchain/redis");
var import_n8n_workflow = require("n8n-workflow");
var import_redis2 = require("redis");
var import_createVectorStoreNode = require("../shared/createVectorStoreNode/createVectorStoreNode");
const REDIS_CREDENTIALS = "redis";
const REDIS_INDEX_NAME = "redisIndex";
const REDIS_KEY_PREFIX = "keyPrefix";
const REDIS_OVERWRITE_DOCUMENTS = "overwriteDocuments";
const REDIS_METADATA_KEY = "metadataKey";
const REDIS_METADATA_FILTER = "metadataFilter";
const REDIS_CONTENT_KEY = "contentKey";
const REDIS_EMBEDDING_KEY = "vectorKey";
const REDIS_TTL = "ttl";
const redisIndexRLC = {
  displayName: "Redis Index",
  name: REDIS_INDEX_NAME,
  type: "resourceLocator",
  default: { mode: "list", value: "" },
  required: true,
  modes: [
    {
      displayName: "From List",
      name: "list",
      type: "list",
      typeOptions: {
        searchListMethod: "redisIndexSearch"
      }
    },
    {
      displayName: "ID",
      name: "id",
      type: "string"
    }
  ]
};
const metadataFilterField = {
  displayName: "Metadata Filter",
  name: REDIS_METADATA_FILTER,
  type: "string",
  description: "The comma-separated list of words by which to apply additional full-text metadata filtering",
  placeholder: "Item1,Item2,Item3",
  default: ""
};
const metadataKeyField = {
  displayName: "Metadata Key",
  name: REDIS_METADATA_KEY,
  type: "string",
  description: "The hash key to be used to store the metadata of the document",
  placeholder: "metadata",
  default: ""
};
const contentKeyField = {
  displayName: "Content Key",
  name: REDIS_CONTENT_KEY,
  type: "string",
  description: "The hash key to be used to store the content of the document",
  placeholder: "content",
  default: ""
};
const embeddingKeyField = {
  displayName: "Embedding Key",
  name: REDIS_EMBEDDING_KEY,
  type: "string",
  description: "The hash key to be used to store the embedding of the document",
  placeholder: "content_vector",
  default: ""
};
const overwriteDocuments = {
  displayName: "Overwrite Documents",
  name: REDIS_OVERWRITE_DOCUMENTS,
  type: "boolean",
  description: "Whether existing documents and the index should be overwritten",
  default: false
};
const keyPrefixField = {
  displayName: "Key Prefix",
  name: REDIS_KEY_PREFIX,
  type: "string",
  description: "Prefix for Redis keys storing the documents",
  placeholder: "doc",
  default: ""
};
const ttlField = {
  displayName: "Time-To-Live",
  name: REDIS_TTL,
  description: "Time-to-live for the documents in seconds",
  placeholder: "0",
  type: "number",
  default: ""
};
const sharedFields = [redisIndexRLC];
const insertFields = [
  {
    displayName: "Options",
    name: "options",
    type: "collection",
    placeholder: "Add Option",
    default: {},
    options: [
      keyPrefixField,
      overwriteDocuments,
      metadataKeyField,
      contentKeyField,
      embeddingKeyField,
      ttlField
    ]
  }
];
const retrieveFields = [
  {
    displayName: "Options",
    name: "options",
    type: "collection",
    placeholder: "Add Option",
    default: {},
    options: [
      metadataFilterField,
      keyPrefixField,
      metadataKeyField,
      contentKeyField,
      embeddingKeyField
    ]
  }
];
const redisConfig = {
  client: null,
  connectionString: ""
};
async function getRedisClient(context) {
  const credentials = await context.getCredentials(REDIS_CREDENTIALS);
  const config = {
    socket: {
      host: credentials.host || "localhost",
      port: credentials.port || 6379,
      tls: credentials.ssl === true
    },
    username: credentials.user,
    password: credentials.password,
    database: credentials.database,
    clientInfoTag: "n8n"
  };
  if (!redisConfig.client || redisConfig.connectionString !== JSON.stringify(config)) {
    if (redisConfig.client) {
      await redisConfig.client.disconnect();
    }
    redisConfig.connectionString = JSON.stringify(config);
    redisConfig.client = (0, import_redis2.createClient)(config);
    if (redisConfig.client) {
      redisConfig.client.on("error", (error) => {
        context.logger.error(`[Redis client] ${error.message}`, { error });
      });
      await redisConfig.client.connect();
    }
  }
  return redisConfig.client;
}
function isStringArray(value) {
  return Array.isArray(value) && value.every((item) => typeof item === "string");
}
async function listIndexes() {
  const client = await getRedisClient(this);
  if (client === null) {
    return { results: [] };
  }
  try {
    const indexes = await client.ft._list();
    if (!isStringArray(indexes)) {
      this.logger.warn("FT._LIST returned unexpected data type");
      return { results: [] };
    }
    const results = indexes.map((index) => ({
      name: index,
      value: index
    }));
    return { results };
  } catch (error) {
    this.logger.info("Failed to get Redis indexes: " + error.message);
    return { results: [] };
  }
}
function getParameter(key, context, itemIndex) {
  return context.getNodeParameter(key, itemIndex, "", {
    extractValue: true
  });
}
function getParameterAsNumber(key, context, itemIndex) {
  return context.getNodeParameter(key, itemIndex, "", {
    extractValue: true
  });
}
class ExtendedRedisVectorSearch extends import_redis.RedisVectorStore {
  constructor(embeddings, options, filter) {
    super(embeddings, options);
    this.defaultFilter = filter;
  }
  async similaritySearchVectorWithScore(query, k) {
    return await super.similaritySearchVectorWithScore(query, k, this.defaultFilter);
  }
}
const getIndexName = getParameter.bind(null, REDIS_INDEX_NAME);
const getKeyPrefix = getParameter.bind(null, `options.${REDIS_KEY_PREFIX}`);
const getOverwrite = getParameter.bind(null, `options.${REDIS_OVERWRITE_DOCUMENTS}`);
const getContentKey = getParameter.bind(null, `options.${REDIS_CONTENT_KEY}`);
const getMetadataFilter = getParameter.bind(null, `options.${REDIS_METADATA_FILTER}`);
const getMetadataKey = getParameter.bind(null, `options.${REDIS_METADATA_KEY}`);
const getEmbeddingKey = getParameter.bind(null, `options.${REDIS_EMBEDDING_KEY}`);
const getTtl = getParameterAsNumber.bind(null, `options.${REDIS_TTL}`);
class VectorStoreRedis extends (0, import_createVectorStoreNode.createVectorStoreNode)({
  meta: {
    displayName: "Redis Vector Store",
    name: "vectorStoreRedis",
    description: "Work with your data in a Redis vector index",
    icon: { light: "file:redis.svg", dark: "file:redis.dark.svg" },
    docsUrl: "https://docs.n8n.io/integrations/builtin/cluster-nodes/root-nodes/n8n-nodes-langchain.vectorstoreredis/",
    credentials: [
      {
        name: REDIS_CREDENTIALS,
        required: true
      }
    ],
    operationModes: ["load", "insert", "retrieve", "update", "retrieve-as-tool"]
  },
  methods: { listSearch: { redisIndexSearch: listIndexes } },
  retrieveFields,
  loadFields: retrieveFields,
  insertFields,
  sharedFields,
  async getVectorStoreClient(context, _filter, embeddings, itemIndex) {
    const client = await getRedisClient(context);
    const indexField = getIndexName(context, itemIndex).trim();
    const keyPrefixField2 = getKeyPrefix(context, itemIndex).trim();
    const metadataField = getMetadataKey(context, itemIndex).trim();
    const contentField = getContentKey(context, itemIndex).trim();
    const embeddingField = getEmbeddingKey(context, itemIndex).trim();
    const filter = getMetadataFilter(context, itemIndex).trim();
    if (client === null) {
      throw new import_n8n_workflow.NodeOperationError(context.getNode(), "Redis client not initialized", {
        itemIndex,
        description: "Please check your Redis connection details"
      });
    }
    try {
      await client.ft.info(indexField);
    } catch (error) {
      throw new import_n8n_workflow.NodeOperationError(context.getNode(), `Index ${indexField} not found`, {
        itemIndex,
        description: "Please check that the index exists in your Redis instance"
      });
    }
    const filterTerms = filter ? filter.split(",").map((s) => s.trim()).filter((s) => s) : [];
    return new ExtendedRedisVectorSearch(
      embeddings,
      {
        redisClient: client,
        indexName: indexField,
        ...keyPrefixField2 ? { keyPrefix: keyPrefixField2 } : {},
        ...metadataField ? { metadataKey: metadataField } : {},
        ...contentField ? { contentKey: contentField } : {},
        ...embeddingField ? { vectorKey: embeddingField } : {}
      },
      filterTerms.length > 0 ? filterTerms : void 0
    );
  },
  async populateVectorStore(context, embeddings, documents, itemIndex) {
    const client = await getRedisClient(context);
    if (client === null) {
      throw new import_n8n_workflow.NodeOperationError(context.getNode(), "Redis client not initialized", {
        itemIndex,
        description: "Please check your Redis connection details"
      });
    }
    try {
      const indexField = getIndexName(context, itemIndex).trim();
      const overwrite = getOverwrite(context, itemIndex);
      const keyPrefixField2 = getKeyPrefix(context, itemIndex).trim();
      const metadataField = getMetadataKey(context, itemIndex).trim();
      const contentField = getContentKey(context, itemIndex).trim();
      const embeddingField = getEmbeddingKey(context, itemIndex).trim();
      const ttl = getTtl(context, itemIndex);
      if (overwrite) {
        await client.ft.dropIndex(indexField, { DD: true });
      }
      await ExtendedRedisVectorSearch.fromDocuments(documents, embeddings, {
        redisClient: client,
        indexName: indexField,
        ...keyPrefixField2 ? { keyPrefix: keyPrefixField2 } : {},
        ...metadataField ? { metadataKey: metadataField } : {},
        ...contentField ? { contentKey: contentField } : {},
        ...embeddingField ? { vectorKey: embeddingField } : {},
        ...ttl ? { ttl } : {}
      });
    } catch (error) {
      context.logger.info(`Error while populating the store: ${error.message}`);
      throw new import_n8n_workflow.NodeOperationError(context.getNode(), `Error: ${error.message}`, {
        itemIndex,
        description: "Please check your index/schema and parameters"
      });
    }
  }
}) {
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  VectorStoreRedis,
  getParameter,
  getParameterAsNumber,
  getRedisClient,
  listIndexes,
  redisConfig
});
//# sourceMappingURL=VectorStoreRedis.node.js.map